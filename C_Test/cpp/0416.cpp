/*
protected 자식관계는 가능하다.
private 비공개
public 전체공개

객체지향 사물을 그에따른 행동을 그대로 실체화 시키는 형태의 프로그래밍이다.
트랜젝션
사과의 갯수만 줄어들고 돈안받고 줄어들면 안되겠지?
판매가 이루어졌으면 돈도 받아야지
이과정 전체가 하나의 트랜젝션이다. (transaction)
과정에서 하나라도 실패하면 롤백한다.

클래스 기반의 생성 방법
stack, heap에 선언하느 2 가지 방법 
ClassName ObjName; 일반 선언방식
ClassName * ptrObj = new ClassName; 동적 할당

참조를 써서 값에 직접 접근한다.??
사과 사는 함수에 파는 함수를 매개변수로 전달해서 처리하면 동시에 2가지 객체에 처리가 된다. 
이러한 함수 호출을 통한 객체간의 대화방법
객체간의 대화 방법 message passing
함수호출을 통해서 객체간의 대화가 가능하다.

캡슐화 무엇인가요 
알아봅시다.


생성자 파괴자 
생성자는 클래스 명을 딴 함수다.
아무것도 매개변수가 없는 애 객체생성만을 하는 애가 디폴트 생성자.
안해주면 컴파일러가 자동으로 디폴트 생성자를 만들어준다. 
매개변순가 없으면 디폴트생성자!!!!!!!!
객체를 생성해서 객체를 리턴하는 함수도 만들 수 있다. 


초기화 리스트 멤버 변수를 대입 업싱 초기화 
#상수나 참조 변수도 초기화 가능 




생성자 멤버 이니셜라이저 
멤버 이니셜라이저는 멤버변수로 선언된 객체의 생성자 호출에 활용된다.
1단계 : 메모리 공간의 할당
2단계 : 이니셜라이저를 이요한 멤버변수(객체)의 초기화
3단계 : 생성자의 몸체부분 실행  
const랑 참조도 초기화를 시킬 수 있다. 그리고 어쨌든 빠름 생성 대입 부분을
빠르게 처리할 수 있다 .

디폴트 생성자 
메모리 공간의 할당 이후에 생성자의 호출까지 완료되어야 '객체;라 할 수 있다. 즉 객체가 되기 위해서는 반드시 하나의 생성자가 호출되어야한다.
디폴트 파괴자


클래스와 배열 this포인터

멤버함수 내에서 this라는 이름의 포인터를 ㅏㅅ용할 수 있는데 이는 객체 자신을 가리키는 용도로 사용되는 포인터이다.




*/

