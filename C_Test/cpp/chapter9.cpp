/*
메모리 모델과 이름 공간
*분할 컴파일
*기억 존속시간, 사용범위, 링크
*위치 지정 new
*이름 공간
c++에서는 메모리에 데이터를 저장하는 방법이 여러가지이다. 
1.메모리에 얼마나 존속 시킬 것인지(기억 존속 시간)
2. 데이터에 대한 접근을 프로그램의 어느 부분에만 허용할 것인지(사용범위, 링크)등을 선택할 수 있다. 
3. new를 사용하여 메모리를 동적으로 대입할 수 있다. 
4. 위치지정 new는 기술의 한 변형을 제공한다. 
5. 이름공간은 데이터 접근을 사용자가 추가로 제어할 수 있도록 해준다. 


**분할 컴파일**
 make 프로그램이 어떤 파일에 의존하는지, 언제 마지막으로 수정되었는지 따위를 추적한다. 
두가지의 서로 다른 함수가 다른 파일에 존재하는데 그 함수들이 같은 형식의 구조체를 사용한다면
이후에 구조체의 변경점이 생겼을 때 두개다  수정해야한다. 이런 문제를 해결하기 위해서 #include가 생겼다.
헤더 파일에 담아서 사용하는것이다.
-구조체 선언과 그구조체를 사용하는 함수들의 원형이 들어 있는 헤더파일
-그 구조체에 관련된 함수들의 코드가 들어ㅇ 있는 소스 코드파일
-그 구조체에 관련된 함수들을 호출하느 코드가 들어있는 소스 코드 파일

이러한 구성은 oop적인 접근을 반영한다. 

** 두 파일에 하나의 헤더 파일을각각 포함 시키면 함 프로그램에 같은 함수의 정의가 두번 있어서
문제가 생긴다. 
보통 헤더파일에는 
함수 원형, #define이나 const를 사용한 기호 상수, 구조체선언, 클래스 선언, 템플릿 선언, 인라인 함수
"coordin.h"로 헤더 파일을 포함하면 작업디렉토리 에서 먼저 찾음 

아무튼 헤더파일은 한번만 들어가 있어야함
#ifndef coordin_h_ p.563
...
#endif 
coordin_h_가 #define에 정의 되지 않은 경우에만 endif사이에 있는 구문들을 처리한다는 말
이거 쓰면 두 번 정의되는 경우를 피할 수 있음 

*/
/*
기억 존속 시간, 사용범위, 링크
-자동 기억 존속 시간 : 함수 매개변수 등이 하나의 블록안에서 살았다가 끝나면 없어지는것
-정적 기억 존속 시간: 함수 밖에서 선언된 변수나 static등이 컴파일 때부터 계속 살아있는거
-동적 기억 존속 시간 : new로 만들어서 delete로 해제하거나 함수가 종료될 때 사라지거나 

사용 범위와 링크
사용 범위는 어떤 이름(변수나 함수 등등) 이 하나의 파일 안에서 얼마나 널리 알려지는가
함수안에서 정의된 변수는 그 함수안에서만 사용 가능하지만 다른곳에섯 사용가능한것들이 있다 .
&&&&&&&&&&링크는 서로 다른 파일에서 이름을 공유하는것을 말한다. 외부링크를 가진 이름은 여러파일들이 공유할 수 있다. 
내부링크를 가진 이름은 한 파일 안에 있는 함수들만 공유할 수 있다. 
지역 변수 전역변수등등 아는거네
d외부링크 여러파일이 이용할 수 있다.
내부링크 해당 파일안에 있는 함수들만 공유할 수 있다.

자동 변수 
함수 매개변수와 함수안에서 선언된 변수 자동기억존속시간 함수 끝나면 사라지는거
선언을 각각 두 블록에서 해주면 포르개름은 두번재 블록에서 정의된 지역변수라고 간주한다. 
그리고 두번째 블록이 끝나 첫 번째 블록으로 오면 다시 올아옴 p.571
3개의 texas는 자신의 주소를 각각 3개 가진다. 프로그램 동작 기간중에 한 개씩만사용한다. 

블록: 중괄호쳐진 구문

지역 사용범위(블록 사용 범위): 변수는 변수를 정의한 블록 안에만 알려진다.
전역 사용범위: 를 가진 정의된 곳부터 아래까지 





*/
/*
자동 변수p/573
자동 변수를 스스로 관리하는 일반적인 방법은 메모리의 일부를 예약해두고(스택으로 이만큼 사용하겠다. 이말이죠)
변수들의 생성과 소멸을 스택으로 관리하는 것이다. 
새로생신 데이터는 먼저 생성된 데이터의 위에 쌓이고 프로그램이 데이터의 사용을 마치면
그 데이터에는 스택에서 제거된다.
블록 내에서 선언된 변수 블록이 끝나면  소멸되는 변수 지역변수라고도 할 수 있다.
두개의 포인터를 사용해서 스택을 관리한다. 한 개의 포인터가 스택메모리의 바닥(시작점) 
다음번 데이터 저장을 위한 비어있는 메모리위치 스택의 꼭대기 지시 , 그리고 사용되면 
새로 추가된 변수들을 지나서 새롭게 사용할 수 있는 빈자리를 지시한다ㅏ. 

스택은 후입선출: 나중에 들어온 변수가 가장 먼저 나간다는 뜻이다. 

레지스터 변수 p.574
노필요 이제 없음 그냥 알지마 알고싶어? 니가해

정적변수 p.574
프로그램이 실행되는 전체 시간동안 존속한다. 수명이 길고 실행중에 변하지않는다. 
정적 변수는 명시적으로 초기화하지 않으면 컴파일러는 모두 0으로 초기화 한다. 
정적배열과 구조체는 ㅡ것의 원소나 멤버가 기본적으로 0으로 설정된다. 

선언방법은 똑같음 외부링크는 중괄호 밖에서 만들어주고 , 내부링크는 중괄호 안에서 선언해준다.
static이라는 제한자를 사용하여 블록안에서 선언하면 링크없이 사용가능하다. 
블록 안에서 선언된 Static은 메모리공간에 처음부터 존재하지만 함수안에서만 사용가능하다. 

유일 정의 원칙 주어진 이름에 하나의 변수만이 가능하다. 
extern int number; 다른 파일에 있는 변수를 가져온거임 
전역적으로 사용해야하는 정적변수의 경우에서 많이  extern을 사용한다. 
그냥 전역변수로 사용하고 파일 include만 해줘도 사용할 수 있지만 extern을 통해서 
다른파일에서 가져온것이라고 설명해준다.
헤더파일에서는 못가져온다. 

*/

/*
제한자 
기억 공간 제한 cv제한자 ㅅㅂ 이게 뭐니

static specifier
파일 범위에 선언 사용시에 내부링크를 갖게하며
지역 변수르 선언할 때 사용하면 링크를 갖지 않는 정적 기억 존속 시간을 갖게 하낟. 

extern specifier 
다른 파엘에서 정의된 변수를 현재 파일에서 사용하고자 할때 선언 하는 키워드이다 
(개발자에게 다른곳에서 이미 선언된 함수, 변수를 가져와서 사용한다는 의밀로 사용)

mutable specifier
구조체나 클래스가 const로 선언되었다 할지라도 해당 객체의 특정멤버를 변경가능하게 만드는 키워드이다
struct data {
    char name[30];
    mutable int accesses;
    ...
};
const data veep = {"Claybourne Clodde", 0, ...};     // const 객체임에 유의!
strcpy(veep.name, "Joye Joux");  // 허용되지 않는다! 객체 veep는 const를 통해 선언되었으므로 기본적으로 수정이 불가능한 객체이다.
veep.Accesses++;                 // 허용된다! accesses 멤버는 mutable을 통해 변경이 가능한 멤버이다.

thread_local Specifier
변수의 존속 시간을 쓰레드의 존속 시간과 일치시코가자 할 때 사용하는 키워드이다.

cv-제한자
const 이는 메모리가 초기화 된 후에는 프로그램이 그모메로리르 변경 할 수 없다는 뜻이다. 
volatile 프로그램 코드가 변경하지 않더라도 특정 메모리 위치에 있는 값이 변경될 수 있다는 것을 나타낸다. 
 
 외부링크를 갖는다 이건 전역 변수의 성질을 이야기하는것이다. 블록 밖에서 선언되었기 때문에 다른곳에서 사용가능하고
 함수를 다른 파일에서 사용가능한것이 외부링크를 갖는다는 의미다.  내부링크는 블록안에서 사용가능하다는 이야기





*/

/*
정적 존속 시간 외부링크
외부 관계성을 지닌 변수는 외부 변수라고부른다. 
외부변수는 정적 저장기관과 파일 범위를 지닌다. 외부 변수는 외부에서 정의되기 때문에
외부 함수 와 연계된다. 
외부 변수는 메인 위 혹은 헤더파일 안에 선언될 수 있다. 
외부 변수는 전역변수라고 불리기도 한다. 
*/
/*
정적 존속 기간, 내부 링크
두 개의 파일에서 같은 이름을 가진 다른 변수를 만들면 에러가 발생한다. 
하나를 static 외부변수로 선언을 한다면, static으로 선언된 변수는 그파일에서만
사용되는 변수로 인식된다.

*/
/*

정적 기억 존속 시간 링크 없음
정적 기억 존속 시간을 갖지만 블록안에 선언되어서 블록은 벗어난 곳에서는 사용 못함


*/
/*
함수와 링크
함수안에서 함수를 정의 할 수는 없다. 
static int priveate(double x); 이렇게 사용하면 하나의 파일에서만 사용가능하다
즉 같은 이름을 다른 파일에서 사용이 가능하다. 왜냐면 static은 파일 하나에서의 내부링크를 주니까? 맞냐?
생성된 스코프(=범위)가 종료한 이후에도 해당 값을 유지하는 변수다. 또한, 정적 변수는 한 번만 초기화되며 프로그램 수명 내내 지속된다.
#include <iostream>

void incrementAndPrint()
{
    static int s_value = 1; // 'static' 키워드를 사용한 '정적 생명 주기', 이 줄은 한번만 실행된다.
    ++s_value;
    std::cout << s_value << '\n';
} // s_value는 여기서 소멸되지 않지만, 접근할 수 없게된다.

int main()
{
    incrementAndPrint();
    incrementAndPrint();
    incrementAndPrint();
}

program outputs:

2
3
4




*/

/*
언어링크 p.594
컴파일러가 내부적인 실행중의 구분을 위해서 같은 이름은 가진것들을 내부적으로 
기호를 붙여서 구분을 해준다.(오버로딩이네요) 맹글링 또는 이름 장식 과정을 거친다. 
이러한 접근 방식을 언어링크라고 한다~~~~~~~~~

*/

/*
&&&&&&&&&&&&&&&링커 
링커는 나눠진 파일들을 합쳐서 실행 가능한 파일로 만드는것이다.


*/

/*
기억 공간 형식과 동적 대입  p.595
동적메모리는 new와 delete연산자에 의해서만 다뤄진다. 
하나의 함수에서 할당하고 다른 함수에서 해제할 수 있다.

new가 실패하는 경우
 필요한 메모리를 확보할 수 없을 때는 new가 null포인터를 리텀해서 처리했다 이제는
 std::bad_alloc 예외를 반환한다. 암튼 있음

 new연산자들, 함수들 대체함수들

*/


/*
이름 공간
이름이 겹치면 안된다. 겹치면 이름 공간 문제라고한다. 
1. 선언 영역 
어디서 선언했는지  함수 안에서 선언하면 그 안에서 지역변수로 사용된다.
모든 함수의 바깥에서 선언하면 전역 변수다. main도 함수다.
2. 잠재 사용 범위
처음으로 그것을 정의한 지점에서 선언영역의 끝까지이다. 선언위치의 윗줄에서는 사용 못함
같은 이름으로 또 함수를 사용하면 해당영역의 변수가 우선하다가 그 영역이 끝나면 다시 이전에 선언된 함수가 온다. 

새로운 이름 공간 기능 p.606
구조체같은 모양을 볼 수 있음 이게 뭐냐면  같은 이름이지만 다른곳에서 정의해서
사용하면 다른것으로 구분해서 사용할 수가 있다

*/

/*
using 선언과 using 지시자 p.607
using 선언은 하나의 특별한 식별자를 사용할 수 있게 만든다.
 하나의 이름만을사용할  수 있게 만든다. 
using 지시자는 그 이름 공간 전체에 접근 할 수 있게 만든다. 
모든 이름을 사용할 수 있게 만든다. p.609
사용범위지정 연산자 jack::pal
아무튼 using 선언과 지시자는 이름충돌을 야기할 수 있다. 
이름공간을 사용하고 사용범위 연산자를 사용하자 그러면 문제 없음



*/
