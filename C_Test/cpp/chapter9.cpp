/*
메모리 모델과 이름 공간
*분할 컴파일
*기억 존속시간, 사용범위, 링크
*위치 지정 new
*이름 공간
c++에서는 메모리에 데이터를 저장하는 방법이 여러가지이다. 
1.메모리에 얼마나 존속 시킬 것인지(기억 존속 시간)
2. 데이터에 대한 접근을 프로그램의 어느 부분에만 허용할 것인지(사용범위, 링크)등을 선택할 수 있다. 
3. new를 사용하여 메모리를 동적으로 대입할 수 있다. 
4. 위치지정 new는 기술의 한 변형을 제공한다. 
5. 이름공간은 데이터 접근을 사용자가 추가로 제어할 수 있도록 해준다. 


**분할 컴파일**
 make 프로그램이 어떤 파일에 의존하는지, 언제 마지막으로 수정되었는지 따위를 추적한다. 
두가지의 서로 다른 함수가 다른 파일에 존재하는데 그 함수들이 같은 형식의 구조체를 사용한다면
이후에 구조체의 변경점이 생겼을 때 두개다  수정해야한다. 이런 문제를 해결하기 위해서 #include가 생겼다.
헤더 파일에 담아서 사용하는것이다.
-구조체 선언과 그구조체를 사용하는 함수들의 원형이 들어 있는 헤더파일
-그 구조체에 관련된 함수들의 코드가 들어ㅇ 있는 소스 코드파일
-그 구조체에 관련된 함수들을 호출하느 코드가 들어있는 소스 코드 파일

** 두 파일에 하나의 헤더 파일을각각 포함 시키면 함 프로그램에 같은 함수의 정의가 두번 있어서
문제가 생긴다. 
보통 헤더파일에는 
함수 원형, #define이나 const를 사용한 기호 상수, 구조체선언, 클래스 선언, 템플릿 선언, 인라인 함수
"coordin.h"로 헤더 파일을 포함하면 작업디렉토리 에서 먼저 찾음 

아무튼 헤더파일은 한번만 들어가 있어야함
#ifndef coordin_h_ p.563
...
#endif 
coordin_h_가 #define에 정의 되지 않은 경우에만 endif사이에 있는 구문들을 처리한다는 말
이거 쓰면 두 번 정의되는 경우를 피할 수 있음 

*/
/*
기억 존속 시간, 사용범위, 링크
-자동 기억 존속 시간 : 함수 매개변수 등이 하나의 블록안에서 살았다가 끝나면 없어지는것
-정적 기억 존속 시간: 함수 밖에서 선언된 변수나 static등이 컴파일 때부터 계속 살아있는거
-동적 기억 존속 시간 : new로 만들어서 delete로 해제하거나 함수가 종료될 때 사라지거나 

사용 범위와 링크
사용 범위는 어떤 이름(변수나 함수 등등) 이 하나의 파일 안에서 얼마나 널리 알려지는가
함수안에서 정의된 변수는 그 함수안에서만 사용 가능하지만 다른곳에섯 사용가능한것들이 있다 .
-&&&&&&&&&&링크는 서로 다른 파일에서 이름을 공유하는것을 말한다. 외부링크를 가진 이름은 여러파일들이 공유할 수 있다. 
내부링크를 가진 이름은 한 파일 안에 있는 함수들만 공유할 수 있다. 
지역 변수 전역변수등등 아는거네


자동 변수 
함수 매개변수와 함수안에서 선언된 변수 자동기억존속시간 함수 끝나면 사라지는거
선언을 각각 두 블록에서 해주면 포르개름은 두번재 블록에서 정의된 지역변수라고 간주한다. 
그리고 두번째 블록이 끝나 첫 번째 블록으로 오면 다시 올아옴 p.571
3개의 texas는 자신의 주소를 각각 3개 가진다. 프로그램 동작 기간중에 한 개씩만사용한다. 




*/


/*
제한자 
기억 공간 제한 cv제한자 ㅅㅂ 이게 뭐니


*/



/*
함수와 링크
함수안에서 함수를 정의 할 수는 없다. 
static int priveate(double x); 이렇게 사용하면 하나의 파일에서만 사용가능하다
즉 같은 이름을 다른 파일에서 사용이 가능하다. 왜냐면 static은 파일 하나에서의 내부링크를 주니까? 맞냐?
생성된 스코프(=범위)가 종료한 이후에도 해당 값을 유지하는 변수다. 또한, 정적 변수는 한 번만 초기화되며 프로그램 수명 내내 지속된다.
#include <iostream>

void incrementAndPrint()
{
    static int s_value = 1; // 'static' 키워드를 사용한 '정적 생명 주기', 이 줄은 한번만 실행된다.
    ++s_value;
    std::cout << s_value << '\n';
} // s_value는 여기서 소멸되지 않지만, 접근할 수 없게된다.

int main()
{
    incrementAndPrint();
    incrementAndPrint();
    incrementAndPrint();
}

program outputs:

2
3
4




*/

/*
언어링크 p.594
컴파일러가 내부적인 실행중의 구분을 위해서 같은 이름은 가진것들을 내부적으로 
기호를 붙여서 구분을 해준다. 맹글링 또는 이름 장식 과정을 거친다. 
이러한 접근 방식을 언어링크라고 한다~~~~~~~~~

*/

/*
&&&&&&&&&&&&&&&링커 
링커는 나눠진 파일들을 합쳐서 실행 가능한 파일로 만드는것이다.


*/

/*
기억 공간 형식과 동적 대입  p.595
동적메모리는 new와 delete연산자에 의해서만 다뤄진다. 
하나의 함수에서 할당하고 다른 함수에서 해제할 수 있다.

new가 실패하는 경우
 필요한 메모리를 확보할 수 없을 때는 new가 null포인터를 리텀해서 처리했다 이제는
 std::bad_alloc 예외를 반환한다. 암튼 있음

 new연산자들, 함수들 대체함수들

*/


/*
이름 공간
이름이 겹치면 안된다. 겹치면 이름 공간 문제라고한다. 
1. 선언 영역 
어디서 선언했는지  함수 안에서 선언하면 그 안에서 지역변수로 사용된다.
모든 함수의 바깥에서 선언하면 전역 변수다. main도 함수다.
2. 잠재 사용 범위
처음으로 그것을 정의한 지점에서 선언영역의 끝까지이다. 선언위치의 윗줄에서는 사용 못함
같은 이름으로 또 함수를 사용하면 해당영역의 변수가 우선하다가 그 영역이 끝나면 다시 이전에 선언된 함수가 온다. 

새로운 이름 공간 기능 p.606
구조체같은 모양을 볼 수 있음 이게 뭐냐면  같은 이름이지만 다른곳에서 정의해서
사용하면 다른것으로 구분해서 사용할 수가 있다

*/

/*
using 선언과 using 지시자 p.607
using 선언은 하나의 특별한 식별자를 사용할 수 있게 만든다.
 하나의 이름만을사용할  수 있게 만든다. 
using 지시자는 그 이름 공간 전체에 접근 할 수 있게 만든다. 
모든 이름을 사용할 수 있게 만든다. p.609
사용범위지정 연산자 jack::pal
아무튼 using 선언과 지시자는 이름충돌을 야기할 수 있다. 
이름공간을 사용하고 사용범위 연산자를 사용하자 그러면 문제 없음



*/
